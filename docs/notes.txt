Conversation with Gemini
in CMS pipelines CONSOLE and LITERAL can be first and/or last in a pipeline spec. other stages, like COUNT or LOCATE cannot be first or last. Question: Can CONSOLE or LITERAL apper between the first and last (source, sink) stages? e.g. PIPE CONSOLE | LITERAL "A" | LITERAL "B"| CONSOLE ? -- but if CONSOLE appears 3 or more times, is it an input or an output the 2nd time?

In the world of z/VM CMS Pipelines, the behavior of a stage depends entirely on its position and whether it is configured to read from or write to the pipeline "plumbing."

To answer your question directly: Yes, CONSOLE and LITERAL can appear anywhere in the pipeline. However, their role changes based on where they sit.

How it works: Source, Filter, or Sink?
In CMS Pipelines, a stage can act as one of three things:

Source: Generates data (must be the first stage).

Filter: Transforms data (middle stages).

Sink: Consumes/disposes of data (must be the last stage).

The LITERAL Stage
LITERAL is unique because it is designed to add a string to the pipeline.

As a Source (First): It creates a record containing the string and passes it to the next stage.

In the Middle: It acts as a "prefix" filter. It passes the literal string it holds to the output first, and then it passes all records it receives from its input stream to its output stream.

As a Sink (Last): It works the same as in the middle, but since there is no "next" stage, it simply passes the data into a dead end (effectively discarding it after the literal is processed).

The CONSOLE Stage
CONSOLE is the bridge between the pipeline and your terminal. Its behavior is strictly positional:

As a Source (First): It waits for you to type at the terminal. Each line you type becomes a record in the pipe. You stop it by entering a null line or the EOF character.

In the Middle: It acts as a transparent monitor. It displays every record passing through it on your screen and simultaneously passes that record to the next stage.

As a Sink (Last): It displays the records on your screen and the pipeline ends there.

Analyzing your example
PIPE CONSOLE | LITERAL "A" | LITERAL "B" | CONSOLE

Here is exactly how the data flows:

CONSOLE (First): It waits for you to type. Let’s say you type "Hello".

LITERAL "A": It outputs "A", then outputs your "Hello".

LITERAL "B": It outputs "B", then outputs the "A" and "Hello" it received.

CONSOLE (Last): It displays everything on your screen.

The result on your screen would be:

Plaintext
B
A
Hello
To your specific question:
"If CONSOLE appears 3 or more times, is it an input or an output the 2nd time?"

If CONSOLE is the 2nd stage in a 4-stage pipe, it is an output and an input. It displays the record to the user (output to terminal) and then passes that same record to the 3rd stage (input to the next stage). It acts like a "T-junction" for your eyes.

Note: If you use CONSOLE in the middle of a pipeline, it can be very useful for debugging to see exactly what the data looks like halfway through a complex transformation!

Would you like me to show you how to use PEEKTO or READTO if you're writing a custom stage to handle these inputs?

If LITERAL is last is that like sending the pipeline output to /dev/null?

In a way, yes—but with a slight "parting gift."

If you place LITERAL at the end of a pipeline, it doesn't just swallow the data like a black hole; it behaves like a filter that has nowhere to send its output.

How LITERAL behaves as a Sink
In CMS Pipelines, every stage (unless specifically written otherwise) tries to pass its output to the primary output stream of the next stage. If there is no next stage:

The LITERAL stage will still "output" its defined string.

It will then "output" all the records it receives from the previous stage.

However, because it is the last stage, those outputs are essentially discarded because there is no consumer connected to its output side.

So, while it effectively acts like /dev/null for the data flowing through the pipe, it is an inefficient way to do it.

Better Alternatives for "Discarding" Data
If your goal is to simply throw data away (the true /dev/null experience), there are more standard stages for that:

Stage	Behavior
HOLE	The official "bit bucket." it accepts all input and discards it immediately. This is the direct equivalent to /dev/null.
COUNT	Discards the data but keeps track of how many records/bytes passed through. Useful if you want to know how much you threw away.
CONSOLE	Discards the data from the pipeline's perspective, but visually "saves" it by printing it to your terminal.
Why LITERAL is rarely used as a sink
Using LITERAL at the end is confusing to anyone reading your code. It implies you wanted to add a prefix to data that was about to be processed, but then you forgot to add the processing stage.

If you just want to end a pipeline and ensure no data spills out onto the CMS ready prompt or terminal, HOLE is your best friend: PIPE < MYDATA FILE A | LOCATE /Error/ | HOLE

Would you like to see how to use the SECONDARY outputs of stages like LOCATE to separate "good" data from "bad" data instead of just discarding it?

so any stage can be last and act like an ineffiecent HOLE stage. If COUNT is last how do you see the count output if there is no CONSOLE after it?

Spot on—any stage that consumes records but has no "next" stage to pass them to acts as a sink. But your observation about COUNT hits on a fundamental rule of CMS Pipelines: stages only pass data through the "plumbing" lines.

If COUNT is the last stage, it calculates the numbers, but it has no one to give them to. It does not automatically print to your screen just because it's finished.

Here is how you actually see that output:

1. The Standard Way: Follow with CONSOLE
To see the results of a COUNT, it is almost always followed by a CONSOLE stage. PIPE < MYDATA FILE A | COUNT LINES | CONSOLE In this case:

COUNT receives the file records, counts them, and (once the file ends) pushes a single record containing the number to its output.

CONSOLE receives that single record and displays it.

2. The "Hidden" Way: Variables
If you are running the pipeline inside a REXX program, you usually don't want the count on the screen; you want it in a variable. You would use the VAR or STEM stages: PIPE < MYDATA FILE A | COUNT LINES | VAR MYCOUNT Now, the number is stored in the REXX variable MYCOUNT, and you can use it later in your script.

Understanding the "Shortstop"
If you truly make COUNT the last stage: PIPE < MYDATA FILE A | COUNT LINES The pipeline will run perfectly, the CPU will do the work of counting every line, and then... nothing. The record containing the count is produced, finds no connected stage to enter, and is discarded.

Key Stages that "Produce" New Data
It helps to think of stages like COUNT, SUMMARY, or UNIQUE as collectors. They "swallow" the incoming stream and then "spit out" a final report. If you don't put a sink like CONSOLE, VAR, or > (disk) after them, that report vanishes.

If you want to...	Use this as the final stage:
See it now	`...
Save it for later	`...
Use it in REXX	`...
Discard it	`...
Would you like to see how to use COUNT to count specific strings using LOCATE first, or perhaps how to get both the count and the data at the same time?

can HOLE appear in the middle and what do stages after it do?

Yes, HOLE can absolutely appear in the middle of a pipeline, but it acts as a "dead end" for any data flowing into it.

When HOLE is in the middle, it behaves like a black hole: it consumes everything sent to it from the previous stage and promptly discards it.

What happens to the stages after HOLE?
The stages following HOLE will generally do nothing and then terminate.

In CMS Pipelines, stages are connected by streams. For a stage to "work," it usually needs an input record to trigger its logic. Since HOLE never passes any records to its output stream, the subsequent stages sit waiting for data that will never arrive.

Once the stage before HOLE finishes and closes its output stream, HOLE closes its input, finishes its work (which was nothing), and closes its output stream. This sends an "End of File" (EOF) signal down the rest of the line, causing all following stages to shut down cleanly.

An Example: The "Silent" Pipe
PIPE < MYDATA FILE A | HOLE | CONSOLE

< MYDATA: Reads the file and sends records to HOLE.

HOLE: Receives records and throws them away. It sends nothing to CONSOLE.

CONSOLE: Receives an EOF signal immediately after HOLE finishes. Your screen remains blank.

Why would you ever put HOLE in the middle?
It seems useless at first glance, but it is actually a powerful tool when using Multistream Pipelines.

In complex pipelines, stages can have "labels" and multiple output streams (Primary and Secondary). You might want to process the data from the Primary stream but intentionally discard everything from the Secondary stream.

Example using a label (myLabel:): PIPE (end ?) < INPUT FILE | myLabel: LOCATE /Error/ | CONSOLE ? myLabel: | HOLE

LOCATE sends lines with "Error" to the Primary stream (which goes to CONSOLE).

LOCATE sends lines without "Error" to the Secondary stream.

The ? marks the end of the first pipeline path. The second path starts after the ?, connecting the Secondary stream of myLabel to HOLE.

In this case, HOLE is in the "middle" of the overall logic, ensuring the non-error records are explicitly discarded so they don't accidentally leak into other parts of the pipe.

Summary of Behavior
Input to HOLE: Absorbed and deleted.

Output from HOLE: Nothing (EOF).

Stages after HOLE: They initialize, receive an EOF signal, and terminate without processing any data.

Would you like to see how to use Labels to split one input into three or four different "sub-pipes" simultaneously?

what about PIPE CONSOLE | COUNT | HOLE | LITERAL "count ignored" | CONSOLE ? -- what would that do?

This example is a fantastic way to illustrate how CMS Pipelines handles "Stage Death" and EOF (End of File) signals.

If you run PIPE CONSOLE | COUNT | HOLE | LITERAL "count ignored" | CONSOLE, here is the step-by-step autopsy of that pipeline:

1. The Execution Flow
CONSOLE (Source): It waits for you to type. You type a few lines and then press Enter on a blank line (EOF). It sends those records to COUNT.

COUNT: It receives your records, increments its internal counter, and stays silent. Once it sees the EOF from the first CONSOLE, it produces one record (the total count) and sends it to HOLE.

HOLE: It receives that single record from COUNT and immediately discards it. Crucially, it then sends an EOF signal to the next stage.

LITERAL "count ignored": This stage is designed to output "count ignored" first, and then pass through whatever it receives. However, in most CMS Pipeline implementations, if the stage preceding it (HOLE) closes the stream immediately, LITERAL may still attempt to fire.

CONSOLE (Sink): It waits to display whatever LITERAL sends.

2. The Result
On your terminal, you would see:

Plaintext
count ignored
3. Why did that happen?
You might wonder: "If HOLE is a dead end, why did the second CONSOLE show anything at all?"

This is the "Prefix" behavior of LITERAL.

LITERAL does not wait for input to send its own string. As soon as the pipeline starts and it becomes its turn to process, it pushes "count ignored" into the output stream.

Then it tries to read from its input (which is connected to HOLE).

HOLE says "I'm finished, here is an EOF."

LITERAL says "Okay, I'm finished too," and closes the stream to the final CONSOLE.

4. What was "Ignored"?
The actual number produced by COUNT is what got "ignored."

If you typed 5 lines, COUNT sent the string "5" to HOLE.

HOLE consumed the "5".

The "5" never reached LITERAL, so it could never be passed to the final CONSOLE.

Summary of the "Dead Zone"
In your specific pipe, HOLE acts as a firewall. Anything produced to the left of HOLE stays to the left of HOLE. Anything to the right of HOLE only happens if those stages can generate their own data (like LITERAL or CHOP with certain options) or if they are simply waiting to terminate.

The final CONSOLE only sees what LITERAL created out of thin air.

Would you like to see what happens if you replace HOLE with NOT? (It's a fun way to invert how stages like LOCATE work!)

so could you have a no-op program: PIPE | HOLE ?

Technically, no. If you try to run exactly PIPE | HOLE on a CMS command line, you will get an error (likely PIPPAL001E No stage separators found or a syntax error).

A pipeline must have at least one stage to be valid, and most CMS Pipeline implementations require that there are no "empty" connectors.

However, if you meant a pipeline that effectively does "nothing" while being syntactically correct, you have a few interesting options:

1. The "Minimal" No-Op
PIPE HOLE If you run this, the HOLE stage starts as a source. Since HOLE by definition contains no data and generates no data, it immediately signals EOF (End of File) and the pipeline terminates. It is the cleanest way to run a pipe that does absolutely nothing.

2. The "Waiting" No-Op
PIPE CONSOLE | HOLE This is a no-op in terms of output, but not in terms of activity.

CONSOLE waits for you to input something.

Whatever you type is sent to HOLE and deleted.

The pipeline only ends when you signal EOF (usually by pressing Enter on a blank line).

3. The "Constant" No-Op
PIPE LITERAL / / | HOLE This creates one blank record, passes it to HOLE (where it vanishes), and ends. It’s slightly more "work" for the CPU than PIPE HOLE, but the result is the same: no output, no changes.

Why would anyone use a No-Op pipe?
In the real world of Mainframe systems, you might use a "no-op" style pipeline for two reasons:

Testing Connectivity: To ensure the PIPE command itself is functioning and that your environment variables are set correctly without accidentally triggering a massive data move.

Dynamic Pipeline Generation: If you have a REXX script that builds a pipeline string based on user input, and the user selects "nothing to do," your script might generate PIPE HOLE rather than logic that crashes the program.

Summary
While PIPE | HOLE is a syntax error because of the lonely pipe character (|), PIPE HOLE is the ultimate z/VM "shrug." It starts, realizes it has nothing to do, and stops.

Would you like to see how to use the DELAY stage to make a pipeline that "does nothing" for a specific amount of time?

does LOCATE accept any delimiters like LOCATE "FOO" and LOCATE /BAR/

In CMS Pipelines, LOCATE is very flexible with delimiters, but there is a specific rule to follow: it uses the first non-blank character after the stage name as the delimiter.

The Delimiter Rule
Unlike REXX, where you might be used to quotes, LOCATE doesn't care if the character is a slash, a quote, or even a letter (though using letters is a recipe for a headache).

LOCATE /FOO/: Standard and most common.

LOCATE "BAR": Perfectly valid. The " acts as the delimiter.

LOCATE .BAZ.: Valid. The . acts as the delimiter.

Wait—what about LOCATE FOO? If you type LOCATE FOO, CMS Pipelines sees the F as the delimiter. It then looks for the next F to close the string. It would try to locate the string OO between two Fs. If it doesn't find a second F, it might throw an error or treat the rest of the stage as the search string depending on the version.

Key Differences: LOCATE vs. LITERAL
While they both deal with strings, their syntax "vibes" are different:

Feature	LOCATE	LITERAL
Purpose	Filters incoming records.	Adds a new record.
Delimiters	Uses the first non-blank char (e.g., /, ", `	`).
Quotes	Quotes are just delimiters.	Quotes are usually included in the string unless handled by REXX.
Pro-Tip: The "No-Delimiter" Shortcut
If you are searching for a string that doesn't contain spaces or special characters, many people use the slash / by habit. However, if you use LOCATE /FOO/, you are being explicit.

If you want to be fancy (or confusing), you could technically do: PIPE LITERAL Hello | LOCATE %ell% | CONSOLE This works because % is the first non-blank character after the word LOCATE.

Watch out for REXX!
If you are running your pipe inside a REXX script: "PIPE ... | LOCATE /"my_var"/ | ..." The quotes there are for REXX to handle the string concatenation, not necessarily for the pipeline itself. This is where most mainframe developers get their "delimiter headaches."

Would you like to see how to use LOCATE with hexadecimal values (like X'00') for finding non-printable characters?

does LITERAL "FOO" and LITERAL /FOO? produce the same output FOO

Actually, no—they will produce different outputs. This is a common "gotcha" because LITERAL and LOCATE handle their arguments very differently.

The Key Difference
Unlike LOCATE, the LITERAL stage does not use delimiters. It treats everything following the first blank space as the literal data to be added to the pipeline.

Command	Pipeline Record Produced	Why?
LITERAL "FOO"	"FOO"	It includes the double quotes as part of the string.
LITERAL /FOO/	/FOO/	It includes the slashes as part of the string.
LITERAL FOO	FOO	This is how you get just the three letters.
Why the confusion?
The confusion usually stems from the fact that many other stages (like LOCATE, FIND, or CHANGE) require delimiters to know where a search string starts and ends. LITERAL is simpler: its job is just to "dump" whatever you typed into the pipe.

If you want the output to be exactly FOO, your stage should simply be: PIPE LITERAL FOO | ...

When would you use quotes with LITERAL?
You only use quotes with LITERAL if you actually want the quotes to appear in your data.

For example, if you are building a CSV file or a command string: PIPE LITERAL "CP QUERY USERID" | CONSOLE

Result: "CP QUERY USERID" (including the quotes)

If you are writing this inside a REXX script, it gets even more layered: address COMMAND 'PIPE LITERAL' "FOO" '| CONSOLE'

Here, REXX strips the quotes before passing the command to the CMS host. The pipeline only sees LITERAL FOO.

But if you did 'PIPE LITERAL ""FOO"" | CONSOLE', REXX would pass one set of quotes to the pipe, and your output would be "FOO".

Summary
LOCATE needs delimiters: LOCATE /FOO/

LITERAL takes everything: LITERAL FOO

Would you like to see how to use the VARLOAD stage to handle strings that have really messy characters (like quotes and slashes mixed together)?




Your Michael A. Wright chats aren’t used to improve our models. Gemini can make mistakes, so double-check it. Your privacy & GeminiOpens in a new window

